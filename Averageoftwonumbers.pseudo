/*
Project: COM HelloWorld (Out-of-Process EXE server) + Console Client
Files included in this single document (copy each to a separate file):

1) Hello.idl
2) Hello_i.h  (generated by midl; included here for convenience)
3) HelloServer.cpp  (COM EXE server implementing IHello and callback)
4) HelloClient.cpp  (console client that uses the COM server)
5) build_and_register_instructions.txt

Notes:
- This example is a minimal, educational implementation. It avoids ATL to show raw COM plumbing.
- You will need the Windows SDK (midl.exe + cl.exe + link.exe) / Visual Studio Developer Command Prompt.
- Steps shown below will compile, register, and run the server. The server must be registered before the client can CoCreateInstance.

-------------------------
Hello.idl
-------------------------

[uuid(9A1D5F10-4C47-4D9A-8D10-3F0C9BB23A11), version(1.0)]
library HelloLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");
};

[uuid(3E4A9E20-66F6-4B3B-9A2C-5F5B6E1A7C22)]
interface ICallback : IUnknown
{
    HRESULT OnHello([in] BSTR message);
};

[uuid(2F7C4D30-B8D5-45D1-91E8-4FA2AE4C9D33)]
interface IHello : IUnknown
{
    HRESULT SayHello([in] BSTR name);
    HRESULT RegisterCallback([in] ICallback* cb);
};

[uuid(5C6E7F40-1A2B-4C77-9D88-9F9F0E5A8D44)]
coclass Hello
{
    [default] interface IHello;
};

-------------------------
Hello_i.h  (convenience paste - normally generated by midl)
-------------------------

// Minimal hand-crafted GUID/header to avoid requiring midl output for reading the example.
#pragma once
#include <windows.h>
#include <unknwn.h>
#include <objbase.h>

// {3E4A9E20-66F6-4B3B-9A2C-5F5B6E1A7C22}
static const IID IID_ICallback =
{ 0x3e4a9e20, 0x66f6, 0x4b3b, {0x9a, 0x2c, 0x5f, 0x5b, 0x6e, 0x1a, 0x7c, 0x22} };

// {2F7C4D30-B8D5-45D1-91E8-4FA2AE4C9D33}
static const IID IID_IHello =
{ 0x2f7c4d30, 0xb8d5, 0x45d1, {0x91, 0xe8, 0x4f, 0xa2, 0xae, 0x4c, 0x9d, 0x33} };

// CLSID_Hello {5C6E7F40-1A2B-4C77-9D88-9F9F0E5A8D44}
static const CLSID CLSID_Hello =
{ 0x5c6e7f40, 0x1a2b, 0x4c77, {0x9d, 0x88, 0x9f, 0x9f, 0x0e, 0x5a, 0x8d, 0x44} };

MIDL_INTERFACE("3E4A9E20-66F6-4B3B-9A2C-5F5B6E1A7C22")
ICallback : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE OnHello(/* [in] */ BSTR message) = 0;
};

MIDL_INTERFACE("2F7C4D30-B8D5-45D1-91E8-4FA2AE4C9D33")
IHello : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SayHello(/* [in] */ BSTR name) = 0;
    virtual HRESULT STDMETHODCALLTYPE RegisterCallback(/* [in] */ ICallback* cb) = 0;
};

-------------------------
HelloServer.cpp
-------------------------

// Minimal out-of-process COM server (EXE) implementing IHello and calling back via ICallback.
// The server supports registration via command-line: /RegServer and /UnregServer, and runs otherwise.

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include "Hello_i.h"

// Simple critical section protected ref counts

class HelloObject : public IHello
{
private:
    LONG m_ref;
    ICallback* m_callback;
public:
    HelloObject() : m_ref(1), m_callback(nullptr) { CoInitializeEx(NULL, COINIT_MULTITHREADED); }
    virtual ~HelloObject() { if (m_callback) m_callback->Release(); CoUninitialize(); }

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) override
    {
        if (!ppvObject) return E_POINTER;
        if (riid == IID_IUnknown) { *ppvObject = static_cast<IUnknown*>(this); }
        else if (riid == IID_IHello) { *ppvObject = static_cast<IHello*>(this); }
        else { *ppvObject = nullptr; return E_NOINTERFACE; }
        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef() override
    {
        return InterlockedIncrement(&m_ref);
    }
    ULONG STDMETHODCALLTYPE Release() override
    {
        ULONG r = InterlockedDecrement(&m_ref);
        if (r == 0) delete this;
        return r;
    }

    // IHello
    HRESULT STDMETHODCALLTYPE SayHello(BSTR name) override
    {
        wprintf(L"[Server] SayHello called with name: %s\n", name);
        // Compose greeting and call back if callback registered
        if (m_callback)
        {
            BSTR msg = SysAllocStringLen(NULL, 256);
            if (!msg) return E_OUTOFMEMORY;
            swprintf_s(msg, 256, L"Hello, %s! (from server via callback)", name);
            HRESULT hr = m_callback->OnHello(msg);
            SysFreeString(msg);
            return hr;
        }
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE RegisterCallback(ICallback* cb) override
    {
        // store callback (AddRef)
        if (m_callback) { m_callback->Release(); m_callback = nullptr; }
        if (cb) { cb->AddRef(); m_callback = cb; }
        wprintf(L"[Server] Callback registered: %p\n", m_callback);
        return S_OK;
    }
};

// Class factory
class HelloFactory : public IClassFactory
{
private:
    LONG m_ref;
public:
    HelloFactory() : m_ref(1) {}
    virtual ~HelloFactory() {}

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) override
    {
        if (!ppvObject) return E_POINTER;
        if (riid == IID_IUnknown || riid == IID_IClassFactory) { *ppvObject = static_cast<IClassFactory*>(this); }
        else { *ppvObject = nullptr; return E_NOINTERFACE; }
        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef() override { return InterlockedIncrement(&m_ref); }
    ULONG STDMETHODCALLTYPE Release() override { ULONG r = InterlockedDecrement(&m_ref); if (r==0) delete this; return r; }

    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppvObject) override
    {
        if (pUnkOuter) return CLASS_E_NOAGGREGATION;
        HelloObject* obj = new HelloObject();
        HRESULT hr = obj->QueryInterface(riid, ppvObject);
        obj->Release(); // QueryInterface added a ref
        return hr;
    }

    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock) override
    {
        if (fLock) CoAddRefServerProcess(); else CoReleaseServerProcess();
        return S_OK;
    }
};

// Registration helpers (very small, registry-based)
static HRESULT RegisterCLSIDInRegistry(REFCLSID clsid, const wchar_t* progID, const wchar_t* descr, const wchar_t* exePath)
{
    wchar_t clsidStr[64];
    StringFromGUID2(clsid, clsidStr, _countof(clsidStr));

    wchar_t key[512];
    HKEY hKey;
    LONG res;

    // HKCR\CLSID\{...}\LocalServer32 = "path to exe"
    swprintf_s(key, L"CLSID\\%s\\LocalServer32", clsidStr);
    res = RegCreateKeyExW(HKEY_CLASSES_ROOT, key, 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL);
    if (res != ERROR_SUCCESS) return HRESULT_FROM_WIN32(res);
    res = RegSetValueExW(hKey, NULL, 0, REG_SZ, (const BYTE*)exePath, (DWORD)((wcslen(exePath)+1)*sizeof(wchar_t)));
    RegCloseKey(hKey);
    if (res != ERROR_SUCCESS) return HRESULT_FROM_WIN32(res);

    // optional: description
    swprintf_s(key, L"CLSID\\%s", clsidStr);
    res = RegCreateKeyExW(HKEY_CLASSES_ROOT, key, 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL);
    if (res == ERROR_SUCCESS) {
        res = RegSetValueExW(hKey, NULL, 0, REG_SZ, (const BYTE*)descr, (DWORD)((wcslen(descr)+1)*sizeof(wchar_t)));
        RegCloseKey(hKey);
    }

    return res == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(res);
}

static HRESULT UnregisterCLSIDFromRegistry(REFCLSID clsid)
{
    wchar_t clsidStr[64];
    StringFromGUID2(clsid, clsidStr, _countof(clsidStr));
    wchar_t key[512];
    swprintf_s(key, L"CLSID\\%s", clsidStr);
    LSTATUS st = RegDeleteTreeW(HKEY_CLASSES_ROOT, key);
    return st == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(st);
}

// Globals
static DWORD g_cookie = 0;

int wmain(int argc, wchar_t* argv[])
{
    HRESULT hr;
    BOOL runAsServer = TRUE;
    BOOL doReg = FALSE, doUnreg = FALSE;

    for (int i = 1; i < argc; ++i)
    {
        if (_wcsicmp(argv[i], L"/RegServer") == 0) { doReg = TRUE; runAsServer = FALSE; }
        else if (_wcsicmp(argv[i], L"/UnregServer") == 0) { doUnreg = TRUE; runAsServer = FALSE; }
    }

    wchar_t modulePath[MAX_PATH]; GetModuleFileNameW(NULL, modulePath, MAX_PATH);

    if (doReg)
    {
        hr = RegisterCLSIDInRegistry(CLSID_Hello, L"Hello.Hello", L"Hello COM Server (sample)", modulePath);
        if (SUCCEEDED(hr)) wprintf(L"Registered server\n"); else wprintf(L"Register failed: 0x%08x\n", hr);
        return 0;
    }
    if (doUnreg)
    {
        hr = UnregisterCLSIDFromRegistry(CLSID_Hello);
        if (SUCCEEDED(hr)) wprintf(L"Unregistered server\n"); else wprintf(L"Unregister failed: 0x%08x\n", hr);
        return 0;
    }

    // Normal run -> register class object and pump messages
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) { wprintf(L"CoInitializeEx failed: 0x%08x\n", hr); return -1; }

    HelloFactory* factory = new HelloFactory();
    DWORD regCookie = 0;
    hr = CoRegisterClassObject(CLSID_Hello, static_cast<IUnknown*>(factory), CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &regCookie);
    if (FAILED(hr)) { wprintf(L"CoRegisterClassObject failed: 0x%08x\n", hr); factory->Release(); CoUninitialize(); return -1; }
    wprintf(L"Server running. Press Enter to exit.\n");

    // Simple message loop - keep server alive until Enter pressed.
    getchar();

    CoRevokeClassObject(regCookie);
    factory->Release();
    CoUninitialize();
    return 0;
}

-------------------------
HelloClient.cpp
-------------------------

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include "Hello_i.h"

// Simple callback implementation
class CallbackImpl : public ICallback
{
private:
    LONG m_ref;
public:
    CallbackImpl() : m_ref(1) {}
    virtual ~CallbackImpl() {}

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) override
    {
        if (!ppvObject) return E_POINTER;
        if (riid == IID_IUnknown || riid == IID_ICallback) { *ppvObject = static_cast<ICallback*>(this); }
        else { *ppvObject = nullptr; return E_NOINTERFACE; }
        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef() override { return InterlockedIncrement(&m_ref); }
    ULONG STDMETHODCALLTYPE Release() override { ULONG r = InterlockedDecrement(&m_ref); if (r==0) delete this; return r; }

    HRESULT STDMETHODCALLTYPE OnHello(BSTR message) override
    {
        wprintf(L"[Client Callback] Received callback message: %s\n", message);
        return S_OK;
    }
};

int wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) { wprintf(L"CoInitializeEx failed: 0x%08x\n", hr); return -1; }

    IHello* pHello = nullptr;
    hr = CoCreateInstance(CLSID_Hello, NULL, CLSCTX_LOCAL_SERVER, IID_IHello, (void**)&pHello);
    if (FAILED(hr)) { wprintf(L"CoCreateInstance failed: 0x%08x\n", hr); CoUninitialize(); return -1; }

    // Create callback and register
    CallbackImpl* cb = new CallbackImpl();
    pHello->RegisterCallback(cb);
    cb->Release(); // server holds a ref if it stored it

    // Call SayHello
    BSTR name = SysAllocString(L"Ashwin");
    pHello->SayHello(name);
    SysFreeString(name);

    pHello->Release();
    CoUninitialize();
    return 0;
}

-------------------------
build_and_register_instructions.txt
-------------------------

1) Save files into a folder, each file as named above.
   - Hello.idl
   - Hello_i.h
   - HelloServer.cpp
   - HelloClient.cpp

2) Open "Developer Command Prompt for VS" (so midl, cl, link are on path).

3) (Optional) Run MIDL to generate headers & proxies. For this educational example we included Hello_i.h hand-written for simplicity. If you prefer, you can run:
   midl /out . Hello.idl
   This will produce Hello_h.h, Hello_i.c, etc.

4) Build server EXE:
   cl /EHsc /MD HelloServer.cpp /link /out:HelloServer.exe

5) Register server (writes CLSID LocalServer32 entry):
   HelloServer.exe /RegServer

6) Run client (in separate console):
   cl /EHsc /MD HelloClient.cpp /link /out:HelloClient.exe
   HelloClient.exe

7) When finished, unregister server:
   HelloServer.exe /UnregServer

Notes and caveats:
- This example intentionally simplifies many details: no proxy/stub registration (if interfaces are not blittable across apartments you may need MIDL-generated proxy/stub dlls). The code uses raw COM interfaces and assumes in-proc layout will work for simple usage on the same machine.
- For production code use MIDL-generated headers and proxy/stub code, handle threading models carefully, and use proper error and lifetime management.
- If CoCreateInstance fails with REGDB_E_CLASSNOTREG, ensure you executed the /RegServer step as admin (writing to HKCR requires permission).


End of document.
