<Window x:Class="TaskbarAppsListing.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Taskbar Apps Listing" Height="500" Width="700">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <!-- Top row: Buttons and input for process ID -->
        <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,0,0,10">
            <Button Content="Refresh List" Click="RefreshButton_Click" Width="120" Margin="0,0,10,0"/>
            <TextBlock VerticalAlignment="Center" Text="Enter Process ID:"/>
            <TextBox Name="ProcessIdTextBox" Width="80" Margin="5,0,10,0"/>
            <Button Content="Bring to Foreground" Click="BringToForegroundButton_Click" Width="150"/>
        </StackPanel>

        <!-- Status text -->
        <TextBlock Name="StatusText" Grid.Row="1" Foreground="DarkBlue" FontWeight="Bold" Margin="0,0,0,10"/>

        <!-- ListView showing taskbar apps -->
        <ListView Name="AppsListView" Grid.Row="2">
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Order" DisplayMemberBinding="{Binding Order}" Width="60"/>
                    <GridViewColumn Header="Process ID" DisplayMemberBinding="{Binding ProcessId}" Width="100"/>
                    <GridViewColumn Header="Process Name" DisplayMemberBinding="{Binding ProcessName}" Width="150"/>
                    <GridViewColumn Header="Window Title" DisplayMemberBinding="{Binding WindowTitle}" Width="300"/>
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</Window>






using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;

namespace TaskbarAppsListing
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            RefreshAppsList();
        }

        #region Win32 API Declarations

        // Delegate for window enumeration
        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
        [DllImport("user32.dll")]
        private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);
        [DllImport("user32.dll")]
        private static extern bool IsWindowVisible(IntPtr hWnd);
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetWindowTextLength(IntPtr hWnd);
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
        // Retrieve the process ID for a window
        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
        // Retrieve extended window styles
        [DllImport("user32.dll", SetLastError = true)]
        private static extern int GetWindowLong(IntPtr hWnd, int nIndex);
        private const int GWL_EXSTYLE = -20;
        private const int WS_EX_TOOLWINDOW = 0x00000080;
        // For bringing a window to foreground
        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll")]
        private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);
        private const int SW_RESTORE = 9; // Restore a minimized window

        // For enumerating child windows
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool EnumChildWindows(IntPtr hwndParent, EnumWindowsProc lpEnumFunc, IntPtr lParam);
        // To find a window by class name
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        // To get window rectangle
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left; 
            public int Top; 
            public int Right; 
            public int Bottom;
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Enumerates all top‑level windows and returns a list of unique TaskbarAppInfo objects.
        /// </summary>
        /// <returns>A list of TaskbarAppInfo for visible windows with non‑empty titles that are not tool windows.</returns>
        private List<TaskbarAppInfo> GetTaskbarApps()
        {
            var apps = new List<TaskbarAppInfo>();
            var seenProcessIds = new HashSet<int>();

            EnumWindows((hWnd, lParam) =>
            {
                // Skip if the window is not visible
                if (!IsWindowVisible(hWnd))
                    return true;

                // Skip tool windows (they usually do not appear on the taskbar)
                int exStyle = GetWindowLong(hWnd, GWL_EXSTYLE);
                if ((exStyle & WS_EX_TOOLWINDOW) != 0)
                    return true;

                // Get the window title length and skip if zero
                int length = GetWindowTextLength(hWnd);
                if (length == 0)
                    return true;

                // Get the window title
                StringBuilder sb = new StringBuilder(length + 1);
                GetWindowText(hWnd, sb, sb.Capacity);
                string windowTitle = sb.ToString();
                if (string.IsNullOrWhiteSpace(windowTitle))
                    return true;

                // Get the process ID
                GetWindowThreadProcessId(hWnd, out uint pid);
                int processId = (int)pid;

                // Only add one entry per process (using the first window found)
                if (!seenProcessIds.Contains(processId))
                {
                    string processName = "";
                    try
                    {
                        Process proc = Process.GetProcessById(processId);
                        processName = proc.ProcessName;
                    }
                    catch { }

                    apps.Add(new TaskbarAppInfo
                    {
                        ProcessId = processId,
                        ProcessName = processName,
                        WindowTitle = windowTitle,
                        WindowHandle = hWnd
                    });
                    seenProcessIds.Add(processId);
                }

                return true; // Continue enumerating
            }, IntPtr.Zero);

            // Now, get the taskbar order (if available) and update our apps
            var orderDict = GetTaskbarOrderDictionary();
            foreach (var app in apps)
            {
                if (orderDict.TryGetValue(app.ProcessId, out int order))
                    app.Order = order;
                else
                    app.Order = -1; // not found in the taskbar order (should not occur)
            }

            return apps;
        }

        /// <summary>
        /// Returns a dictionary mapping process ID to its taskbar order.
        /// Order is determined from the taskbar container’s child windows (rightmost is order 1).
        /// </summary>
        private Dictionary<int, int> GetTaskbarOrderDictionary()
        {
            var dict = new Dictionary<int, int>();
            // Get the taskbar container window (class name "MSTaskListWClass")
            IntPtr taskList = FindWindow("MSTaskListWClass", null);
            if (taskList == IntPtr.Zero)
                return dict;

            var children = new List<(IntPtr hwnd, int left, int processId)>();

            EnumChildWindows(taskList, (childHwnd, lParam) =>
            {
                if (GetWindowRect(childHwnd, out RECT rect))
                {
                    int left = rect.Left;
                    GetWindowThreadProcessId(childHwnd, out uint pid);
                    int procId = (int)pid;
                    children.Add((childHwnd, left, procId));
                }
                return true;
            }, IntPtr.Zero);

            // Sort children by left coordinate ascending.
            children.Sort((a, b) => a.left.CompareTo(b.left));

            // Assign order from rightmost end:
            // Rightmost (largest left coordinate) gets order 1.
            int count = children.Count;
            for (int i = 0; i < count; i++)
            {
                // In sorted order (leftmost first), reverse index gives order.
                int order = count - i;
                var child = children[i];
                // If multiple buttons belong to the same process, choose the smallest order (i.e. rightmost)
                if (dict.ContainsKey(child.processId))
                {
                    dict[child.processId] = Math.Min(dict[child.processId], order);
                }
                else
                {
                    dict.Add(child.processId, order);
                }
            }
            return dict;
        }

        /// <summary>
        /// Refresh the ListView with current taskbar apps.
        /// </summary>
        private void RefreshAppsList()
        {
            var apps = GetTaskbarApps();
            AppsListView.ItemsSource = apps;
            StatusText.Text = $"Found {apps.Count} taskbar app(s).";
        }

        /// <summary>
        /// Given a process ID, looks for a corresponding taskbar window and returns its handle.
        /// </summary>
        private IntPtr GetTaskbarWindowHandleForProcess(int processId)
        {
            var apps = GetTaskbarApps();
            foreach (var app in apps)
            {
                if (app.ProcessId == processId)
                    return app.WindowHandle;
            }
            return IntPtr.Zero;
        }

        #endregion

        #region UI Event Handlers

        private void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            RefreshAppsList();
        }

        /// <summary>
        /// When the user clicks "Bring to Foreground", we check if the entered process ID is in the taskbar list.
        /// If found, we restore and bring the window to the foreground.
        /// </summary>
        private void BringToForegroundButton_Click(object sender, RoutedEventArgs e)
        {
            if (!int.TryParse(ProcessIdTextBox.Text, out int processId))
            {
                StatusText.Text = "Please enter a valid process ID.";
                return;
            }

            // Get the window handle for the given process ID from our taskbar list.
            IntPtr hwnd = GetTaskbarWindowHandleForProcess(processId);
            if (hwnd == IntPtr.Zero)
            {
                StatusText.Text = $"No taskbar window found for process ID {processId}.";
                return;
            }

            // Restore (if minimized) and bring the window to foreground.
            ShowWindowAsync(hwnd, SW_RESTORE);
            SetForegroundWindow(hwnd);
            StatusText.Text = $"Process ID {processId} window brought to foreground.";
        }

        #endregion
    }

    // A simple class to hold information about taskbar apps.
    public class TaskbarAppInfo
    {
        public int Order { get; set; }         // The order (1 = rightmost)
        public int ProcessId { get; set; }
        public string ProcessName { get; set; }
        public string WindowTitle { get; set; }
        public IntPtr WindowHandle { get; set; }
    }
}
