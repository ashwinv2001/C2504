// Messenger.cpp : Implementation of CMessenger

#include "pch.h"
#include "Messenger.h"

// CRITICAL: Include the generated C file to define the GUIDs
#include "ComServerExe_i.c" 

// Called by Client A
STDMETHODIMP CMessenger::SendTask( BSTR taskName )
{
    // Pass the message to the event firing system
    return Fire_OnTaskRequested( taskName );
}

// Fires the event to Client B (and others)
HRESULT CMessenger::Fire_OnTaskRequested( BSTR taskName )
{
    CComPtr<IConnectionPointContainer> spCPC;
    if( FAILED( this->QueryInterface( IID_IConnectionPointContainer, ( void** )&spCPC ) ) ) return E_FAIL;

    CComPtr<IConnectionPoint> spCP;
    // Uses the ID from the included _i.c file
    if( FAILED( spCPC->FindConnectionPoint( DIID__IMessengerEvents, &spCP ) ) ) return E_FAIL;

    CComPtr<IEnumConnections> spEnum;
    if( FAILED( spCP->EnumConnections( &spEnum ) ) ) return E_FAIL;

    CONNECTDATA cd;
    ULONG fetched = 0;
    while( spEnum->Next( 1, &cd, &fetched ) == S_OK )
    {
        if( cd.pUnk )
        {
            CComPtr<IDispatch> spDisp;
            if( SUCCEEDED( cd.pUnk->QueryInterface( IID_IDispatch, ( void** )&spDisp ) ) )
            {
                DISPPARAMS dp = { 0 };
                VARIANTARG var;
                VariantInit( &var );
                var.vt = VT_BSTR;
                var.bstrVal = taskName;
                dp.cArgs = 1;
                dp.rgvarg = &var;

                // Invoke ID 1 (OnTaskRequested)
                spDisp->Invoke( 1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dp, NULL, NULL, NULL );
            }
            cd.pUnk->Release();
        }
    }
    return S_OK;
}









// ComServerExe.idl : IDL source for ComServerExe

// This file will be processed by the MIDL tool to
// produce the type library (ComServerExe.tlb) and marshalling code.


import "oaidl.idl";
import "ocidl.idl";

[
	object,
	uuid( a53801c3-b7f1-4ec0-886b-6cc2d535e000 ),
	dual,
	nonextensible,
	pointer_default( unique )
]
interface IMessenger : IDispatch
{
	// Method for Client A to call
	[id( 1 )] HRESULT SendTask( [in] BSTR taskName );
};

[
	uuid( 797aa386-966c-490d-955a-277686259333 ),
	version( 1.0 ),
]
library ComServerExeLib
{
	importlib( "stdole2.tlb" );

	// Event Interface definition
	[
		uuid( 12345678-AAAA-BBBB-CCCC-1234567890AB ) // Unique Event ID
	]
		dispinterface _IMessengerEvents
	{
		properties:
		methods:
			[id( 1 )] void OnTaskRequested( [in] BSTR taskName );
	};

	[
		uuid( 916282a4-6857-49d5-b8ae-5e922164f6c1 )
	]
		coclass Messenger
	{
		[default] interface IMessenger;
		// Add the source interface so clients can listen
		[default, source] dispinterface _IMessengerEvents;
	};
};

import "shobjidl.idl";







// Messenger.h : Declaration of the CMessenger

#pragma once
#include "resource.h"       // main symbols
#include "ComServerExe_i.h"
#include <atlcom.h>
#include <atlctl.h> // Required for Connection Points

#if defined(_WIN32_WCE) && !defined(_CE_DCOM) && !defined(_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA)
#error "Single-threaded COM objects are not properly supported on Windows CE platform..."
#endif

using namespace ATL;

// CMessenger

class ATL_NO_VTABLE CMessenger :
	public CComObjectRootEx<CComSingleThreadModel>, // For EXE, MultiThreadModel is often better, but Single works if serialized
	public CComCoClass<CMessenger, &CLSID_Messenger>,

	// 1. Support for holding connections
	public IConnectionPointContainerImpl<CMessenger>,

	// 2. Implementation of the specific Event Interface
	public IConnectionPointImpl<CMessenger, &DIID__IMessengerEvents, CComDynamicUnkArray>,

	public IDispatchImpl<IMessenger, &IID_IMessenger, &LIBID_ComServerExeLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
	CMessenger()
	{
	}

	// [NEW] CRITICAL: This makes all clients talk to the ONE same EXE instance
	DECLARE_CLASSFACTORY_SINGLETON( CMessenger )

	DECLARE_REGISTRY_RESOURCEID( 106 )

	BEGIN_COM_MAP( CMessenger )
		COM_INTERFACE_ENTRY( IMessenger )
		COM_INTERFACE_ENTRY( IDispatch )
		// [NEW] Expose Connection Points
		COM_INTERFACE_ENTRY( IConnectionPointContainer )
	END_COM_MAP()

	// [NEW] Map the event interface
	BEGIN_CONNECTION_POINT_MAP( CMessenger )
		CONNECTION_POINT_ENTRY( DIID__IMessengerEvents )
	END_CONNECTION_POINT_MAP()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}

	void FinalRelease()
	{
	}

public:
	// Method Declarations
	STDMETHOD( SendTask )( BSTR taskName );
	HRESULT Fire_OnTaskRequested( BSTR taskName );
};

OBJECT_ENTRY_AUTO( __uuidof( Messenger ), CMessenger )











// ComServerExe.cpp : Implementation of WinMain


#include "pch.h"
#include "framework.h"
#include "resource.h"
#include "ComServerExe_i.h"


using namespace ATL;


class CComServerExeModule : public ATL::CAtlExeModuleT< CComServerExeModule >
{
public :
	DECLARE_LIBID(LIBID_ComServerExeLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_COMSERVEREXE, "{797aa386-966c-490d-955a-277686259333}")
};

CComServerExeModule _AtlModule;



//
extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, HINSTANCE /*hPrevInstance*/,
								LPTSTR /*lpCmdLine*/, int nShowCmd)
{
	return _AtlModule.WinMain(nShowCmd);
}











#include <iostream>
#include <string>
#include <atlbase.h>
#include <atlcom.h>

// =========================================================
// These files are generated in ComServerExe project folder.
// =========================================================
#include "../../ComServerExe/ComServerExe/ComServerExe_i.h"
#include "../../ComServerExe/ComServerExe/ComServerExe_i.c"

// Standard ATL Module for Console App
class CClientModule : public CAtlExeModuleT<CClientModule> {};
CClientModule _AtlModule;

// Global Name for this Client
std::wstring g_ClientName;



// ===========================================================================
// EVENT SINK (LISTENER)
// This receives the "OnTaskRequested" event from the Server
// ===========================================================================
class CClientSink : public IDispEventImpl<0, CClientSink, &DIID__IMessengerEvents, &LIBID_ComServerExeLib, 1, 0>
{
public:
    // This matches [id(1)] in your IDL
    void __stdcall OnTaskRequested1( BSTR taskName )
    {
        std::wstring msg( taskName, SysStringLen( taskName ) );

        // Filter: Don't show messages sent by ME
        std::wstring myTag = L"[" + g_ClientName + L"]";
        if( msg.find( myTag ) == 0 ) return;

        // Print incoming message
        std::wcout << L"\n";
        std::wcout << L"--------------------------------------------------\n";
        std::wcout << L" INCOMING: " << msg << L"\n";
        std::wcout << L"--------------------------------------------------\n";
        std::wcout << L"Command > ";
    }

    


    BEGIN_SINK_MAP( CClientSink )
        SINK_ENTRY_EX( 0, DIID__IMessengerEvents, 1, OnTaskRequested1 )
    END_SINK_MAP()
};

// ===========================================================================
// MAIN
// ===========================================================================
int main()
{
    // Initialize COM
    HRESULT hr = CoInitializeEx( nullptr, COINIT_MULTITHREADED );
    if( FAILED( hr ) ) return 1;

    {
        CComPtr<IMessenger> pMessenger;

        // CRITICAL CHANGE FOR EXE SERVER:
        // Use CLSCTX_LOCAL_SERVER. This finds the running EXE.
        hr = pMessenger.CoCreateInstance( CLSID_Messenger, nullptr, CLSCTX_LOCAL_SERVER );

        if( SUCCEEDED( hr ) )
        {
            CClientSink sink;
            // Connect the events
            hr = sink.DispEventAdvise( pMessenger );

            if( SUCCEEDED( hr ) )
            {
                std::cout << "Successfully connected to Shared EXE Server!\n";

                // Get Client Name
                std::cout << "Enter your Name: ";
                std::string tempName;
                std::getline( std::cin, tempName );
                g_ClientName = std::wstring( tempName.begin(), tempName.end() );

                std::cout << "Welcome " << tempName << ". Type a message and hit Enter.\n";
                std::cout << "Type 'exit' to quit.\n";
                std::cout << "Command > ";

                std::string input;
                while( std::getline( std::cin, input ) )
                {
                    if( input == "exit" ) break;

                    if( !input.empty() )
                    {
                        // Format: [Name] Message
                        std::string fullMsg = "[" + tempName + "] " + input;
                        CComBSTR bstrMsg( fullMsg.c_str() );

                        // Send to Server
                        pMessenger->SendTask( bstrMsg );
                        std::cout << "Command > ";
                    }
                }
                sink.DispEventUnadvise( pMessenger );
            }
            else
            {
                std::cout << "Connected to Server, but Event Subscription failed.\n";
            }
        }
        else
        {
            std::cout << "Failed to connect to ComServerExe.\n";
            std::cout << "1. Did you build the Server?\n";
            std::cout << "2. Did you run 'ComServerExe.exe /RegServer' as Admin?\n";
        }
    }

    CoUninitialize();
    return 0;
}




