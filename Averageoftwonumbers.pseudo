<Window x:Class="Wpftest4.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Taskbar App Switcher" Height="350" Width="400">
    <Grid>
        <TextBlock Text="Enter Process ID:" Margin="10,10,0,0" VerticalAlignment="Top" />
        <TextBox Name="ProcessIdTextBox" Width="200" Height="25" Margin="10,30,0,0"
                 HorizontalAlignment="Left"/>

        <Button Content="Bring to Foreground" Width="200" Height="30"
                Margin="10,70,0,0" Click="BringToForeground_Click"/>

        <TextBlock Name="StatusText" Foreground="Red" Margin="10,110,0,0"/>
        
        <ListView Name="TaskbarList" Margin="10,150,10,10">
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Process ID" Width="100" DisplayMemberBinding="{Binding ProcessId}"/>
                    <GridViewColumn Header="App Name" Width="200" DisplayMemberBinding="{Binding AppName}"/>
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</Window>





using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows;
using System.Windows.Automation;

namespace Wpftest4
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            LoadTaskbarApps();
        }

        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll")]
        private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);

        private const int SW_RESTORE = 9;

        private void LoadTaskbarApps()
        {
            List<TaskbarApp> taskbarApps = new List<TaskbarApp>();

            foreach (var process in Process.GetProcesses())
            {
                if (process.MainWindowHandle != IntPtr.Zero)
                {
                    taskbarApps.Add(new TaskbarApp
                    {
                        ProcessId = process.Id,
                        AppName = process.ProcessName
                    });
                }
            }

            TaskbarList.ItemsSource = taskbarApps;
        }

        private void BringToForeground_Click(object sender, RoutedEventArgs e)
        {
            if (int.TryParse(ProcessIdTextBox.Text, out int processId))
            {
                var process = Process.GetProcesses().FirstOrDefault(p => p.Id == processId);
                if (process == null || process.MainWindowHandle == IntPtr.Zero)
                {
                    StatusText.Text = "Process not found in taskbar!";
                    return;
                }

                if (!ClickTaskbarIcon(processId))
                {
                    ShowWindowAsync(process.MainWindowHandle, SW_RESTORE);
                    SetForegroundWindow(process.MainWindowHandle);
                }

                StatusText.Text = "App brought to foreground!";
            }
            else
            {
                StatusText.Text = "Invalid Process ID.";
            }
        }

        private bool ClickTaskbarIcon(int processId)
        {
            var taskbar = AutomationElement.RootElement.FindFirst(TreeScope.Children,
                new PropertyCondition(AutomationElement.ClassNameProperty, "Shell_TrayWnd"));

            if (taskbar == null)
                return false;

            var taskList = taskbar.FindFirst(TreeScope.Children,
                new PropertyCondition(AutomationElement.ClassNameProperty, "MSTaskListWClass"));

            if (taskList == null)
                return false;

            foreach (AutomationElement child in taskList.FindAll(TreeScope.Children, Condition.TrueCondition))
            {
                var process = GetProcessIdFromElement(child);
                if (process == processId)
                {
                    var invokePattern = child.GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
                    invokePattern?.Invoke();
                    return true;
                }
            }

            return false;
        }

        private int GetProcessIdFromElement(AutomationElement element)
        {
            int processId = -1;
            try
            {
                object processIdObj = element.GetCurrentPropertyValue(AutomationElement.ProcessIdProperty);
                if (processIdObj != AutomationElement.NotSupported)
                {
                    processId = (int)processIdObj;
                }
            }
            catch { }
            return processId;
        }
    }

    public class TaskbarApp
    {
        public int ProcessId { get; set; }
        public string AppName { get; set; }
    }
}
