<Window x:Class="WpfUwpRestorer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Restore and Maximize UWP App" Height="200" Width="400"
        WindowStartupLocation="CenterScreen">
  <Grid>
    <TextBlock Text="Enter Process ID:" 
               Margin="20,20,0,0" 
               HorizontalAlignment="Left" 
               VerticalAlignment="Top" />
    <TextBox x:Name="txtProcessId" 
             Width="200" 
             Height="25" 
             Margin="20,50,0,0" 
             HorizontalAlignment="Left" 
             VerticalAlignment="Top"/>
    <Button Content="Restore &amp; Maximize" 
            Width="200" 
            Height="30" 
            Margin="20,90,0,0" 
            HorizontalAlignment="Left" 
            VerticalAlignment="Top" 
            Click="OnRestoreAndMaximizeClick"/>
  </Grid>
</Window>





using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Automation;

namespace WpfUwpRestorer
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        #region P/Invoke Declarations

        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);
        
        [DllImport("user32.dll")]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
        
        [DllImport("user32.dll")]
        private static extern bool EnumChildWindows(IntPtr hWndParent, EnumWindowsProc lpEnumFunc, IntPtr lParam);
        
        [DllImport("user32.dll")]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);
        
        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
        
        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
        
        const int SW_RESTORE = 9; // restores a minimized window
        const uint WM_SYSCOMMAND = 0x0112;
        const int SC_MAXIMIZE = 0xF030;

        #endregion

        private async void OnRestoreAndMaximizeClick(object sender, RoutedEventArgs e)
        {
            if (int.TryParse(txtProcessId.Text, out int processId))
            {
                try
                {
                    // Obtain the real window handle for the process.
                    IntPtr hWnd = await Task.Run(() => FindWindowByProcessId(processId));

                    if (hWnd != IntPtr.Zero)
                    {
                        // Bring the window to the foreground.
                        SetForegroundWindow(hWnd);
                        await Task.Delay(500);

                        // Restore the window (in case it’s minimized).
                        ShowWindow(hWnd, SW_RESTORE);
                        await Task.Delay(500);

                        // First try to maximize via UI Automation.
                        bool uiMaximized = MaximizeWindowUsingUIAutomation(hWnd);

                        // If UI Automation did not work, fall back to sending a maximize command.
                        if (!uiMaximized)
                        {
                            SendMessage(hWnd, WM_SYSCOMMAND, new IntPtr(SC_MAXIMIZE), IntPtr.Zero);
                        }
                    }
                    else
                    {
                        MessageBox.Show("Could not find a valid window for the given process ID.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error: {ex.Message}", "Exception", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            else
            {
                MessageBox.Show("Please enter a valid process ID.", "Invalid Input", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Finds the real window handle given a process ID.
        /// For standard Win32 apps, proc.MainWindowHandle is used.
        /// For UWP apps (like Calculator) which typically have MainWindowHandle==0,
        /// we enumerate the child windows of ApplicationFrameHost.
        /// </summary>
        private IntPtr FindWindowByProcessId(int processId)
        {
            // First, try the process’s MainWindowHandle.
            try
            {
                Process proc = Process.GetProcessById(processId);
                if (proc != null && proc.MainWindowHandle != IntPtr.Zero)
                {
                    return proc.MainWindowHandle;
                }
            }
            catch { }

            // For UWP apps, MainWindowHandle is often zero.
            // Enumerate ApplicationFrameHost windows and then their children.
            Process[] frameHosts = Process.GetProcessesByName("ApplicationFrameHost");
            foreach (Process host in frameHosts)
            {
                if (host.MainWindowHandle != IntPtr.Zero)
                {
                    IntPtr found = IntPtr.Zero;
                    EnumChildWindows(host.MainWindowHandle, (child, lParam) =>
                    {
                        GetWindowThreadProcessId(child, out uint childPid);
                        if (childPid == processId)
                        {
                            found = child;
                            return false; // stop enumeration
                        }
                        return true;
                    }, IntPtr.Zero);
                    if (found != IntPtr.Zero)
                        return found;
                }
            }
            return IntPtr.Zero;
        }

        /// <summary>
        /// Attempts to find and invoke a "Maximize" button via UI Automation.
        /// Returns true if successful.
        /// </summary>
        private bool MaximizeWindowUsingUIAutomation(IntPtr hWnd)
        {
            try
            {
                AutomationElement element = AutomationElement.FromHandle(hWnd);
                if (element != null)
                {
                    // Look for a button named "Maximize" in the automation tree.
                    AutomationElement maxButton = element.FindFirst(
                        TreeScope.Subtree,
                        new PropertyCondition(AutomationElement.NameProperty, "Maximize")
                    );
                    if (maxButton != null && maxButton.TryGetCurrentPattern(InvokePattern.Pattern, out object pattern))
                    {
                        ((InvokePattern)pattern).Invoke();
                        return true;
                    }
                }
            }
            catch { }
            return false;
        }
    }
}
