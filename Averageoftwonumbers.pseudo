<Window x:Class="WpfUwpRestorer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Restore and Maximize UWP App" Height="200" Width="400"
        WindowStartupLocation="CenterScreen">
  <Grid>
    <TextBlock Text="Enter Process ID:" 
               Margin="20,20,0,0" 
               HorizontalAlignment="Left" 
               VerticalAlignment="Top" />
    <TextBox x:Name="txtProcessId" 
             Width="200" 
             Height="25" 
             Margin="20,50,0,0" 
             HorizontalAlignment="Left" 
             VerticalAlignment="Top"/>
    <Button Content="Restore &amp; Maximize" 
            Width="200" 
            Height="30" 
            Margin="20,90,0,0" 
            HorizontalAlignment="Left" 
            VerticalAlignment="Top" 
            Click="OnRestoreAndMaximizeClick"/>
  </Grid>
</Window>






using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Automation;

namespace WpfUwpRestorer
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        // P/Invoke declarations for basic window functions.
        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll")]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        const int SW_MAXIMIZE = 3; // standard command

        /// <summary>
        /// Click handler for the "Restore &amp; Maximize" button.
        /// </summary>
        private async void OnRestoreAndMaximizeClick(object sender, RoutedEventArgs e)
        {
            if (int.TryParse(txtProcessId.Text, out int processId))
            {
                try
                {
                    // Try to get the window handle.
                    IntPtr hWnd = await Task.Run(() => FindWindowByProcessId(processId));
                    if (hWnd != IntPtr.Zero)
                    {
                        // Bring the window to the foreground.
                        SetForegroundWindow(hWnd);
                        await Task.Delay(500);

                        // First, attempt to restore it.
                        RestoreWindow(hWnd, processId);
                        await Task.Delay(500);

                        // Then, maximize it.
                        if (!MaximizeWindow(hWnd))
                        {
                            MessageBox.Show("Failed to maximize the window.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                        }
                    }
                    else
                    {
                        MessageBox.Show("Could not find a valid window for the given Process ID.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error: {ex.Message}", "Exception", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            else
            {
                MessageBox.Show("Please enter a valid Process ID.", "Invalid Input", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Finds the main window handle for the given process ID.
        /// For most Win32 apps (like Notepad) this is proc.MainWindowHandle;
        /// for UWP apps the handle may be hosted in ApplicationFrameHost.
        /// </summary>
        private IntPtr FindWindowByProcessId(int processId)
        {
            Process proc = Process.GetProcessById(processId);
            if (proc != null && proc.MainWindowHandle != IntPtr.Zero)
            {
                return proc.MainWindowHandle;
            }

            // If not found (as can happen for UWP Calculator),
            // try to locate a window from ApplicationFrameHost.
            Process[] frameHosts = Process.GetProcessesByName("ApplicationFrameHost");
            foreach (Process frameHost in frameHosts)
            {
                if (frameHost.MainWindowHandle != IntPtr.Zero)
                    return frameHost.MainWindowHandle;
            }
            return IntPtr.Zero;
        }

        /// <summary>
        /// Attempts to restore a minimized UWP window.
        /// First it looks for a "Restore" button in the UI Automation tree.
        /// If not found, it tries clicking the app’s taskbar icon.
        /// </summary>
        private void RestoreWindow(IntPtr hWnd, int processId)
        {
            try
            {
                AutomationElement element = AutomationElement.FromHandle(hWnd);
                if (element != null)
                {
                    // Look for a button named "Restore" (common in standard window frames).
                    AutomationElement restoreButton = element.FindFirst(
                        TreeScope.Subtree,
                        new PropertyCondition(AutomationElement.NameProperty, "Restore")
                    );
                    if (restoreButton != null)
                    {
                        InvokePattern ip = restoreButton.GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
                        ip?.Invoke();
                        return;
                    }
                }
            }
            catch { /* ignore UI Automation exceptions */ }

            // If no restore button was found, try clicking the taskbar icon.
            ClickTaskbarIcon(processId);
        }

        /// <summary>
        /// Attempts to maximize the window.
        /// For Win32 apps, ShowWindow may work; for UWP we try to invoke the "Maximize" button.
        /// </summary>
        private bool MaximizeWindow(IntPtr hWnd)
        {
            try
            {
                AutomationElement element = AutomationElement.FromHandle(hWnd);
                if (element != null)
                {
                    // Look for a button named "Maximize"
                    AutomationElement maxButton = element.FindFirst(
                        TreeScope.Subtree,
                        new PropertyCondition(AutomationElement.NameProperty, "Maximize")
                    );
                    if (maxButton != null)
                    {
                        InvokePattern ip = maxButton.GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
                        ip?.Invoke();
                        return true;
                    }
                }
                // Fallback for Win32 apps.
                return ShowWindow(hWnd, SW_MAXIMIZE);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Attempts to simulate a click on the app’s taskbar button.
        /// This is used as a fallback to restore a minimized UWP app.
        /// </summary>
        private bool ClickTaskbarIcon(int processId)
        {
            try
            {
                Process proc = Process.GetProcessById(processId);
                if (proc == null)
                    return false;
                // Use the process name as the expected taskbar button name.
                string appName = proc.ProcessName;  // e.g. "Calculator"

                // Get the taskbar AutomationElement.
                AutomationElement taskbar = AutomationElement.RootElement.FindFirst(
                    TreeScope.Children,
                    new PropertyCondition(AutomationElement.ClassNameProperty, "Shell_TrayWnd")
                );
                if (taskbar == null)
                    return false;

                // Within the taskbar, the task list usually has a class "MSTaskListWClass".
                AutomationElement taskList = taskbar.FindFirst(
                    TreeScope.Descendants,
                    new PropertyCondition(AutomationElement.ClassNameProperty, "MSTaskListWClass")
                );
                if (taskList == null)
                    return false;

                // Find a button whose Name property matches the app name.
                AutomationElement taskbarButton = taskList.FindFirst(
                    TreeScope.Descendants,
                    new AndCondition(
                        new PropertyCondition(AutomationElement.NameProperty, appName),
                        new PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.Button)
                    )
                );
                if (taskbarButton != null)
                {
                    InvokePattern ip = taskbarButton.GetCurrentPattern(InvokePattern.Pattern) as InvokePattern;
                    ip?.Invoke();
                    return true;
                }
            }
            catch { }
            return false;
        }
    }
}
