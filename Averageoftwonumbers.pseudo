<Window x:Class="TaskbarAppsListing.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Taskbar Apps Listing" Height="350" Width="600">
    <Grid>
        <StackPanel>
            <Button Content="Refresh List" Click="RefreshButton_Click" 
                    Margin="10" Width="120" HorizontalAlignment="Left"/>
            <ListView Name="AppsListView" Margin="10">
                <ListView.View>
                    <GridView>
                        <GridViewColumn Header="Process ID" DisplayMemberBinding="{Binding ProcessId}" Width="100"/>
                        <GridViewColumn Header="Process Name" DisplayMemberBinding="{Binding ProcessName}" Width="150"/>
                        <GridViewColumn Header="Window Title" DisplayMemberBinding="{Binding WindowTitle}" Width="300"/>
                    </GridView>
                </ListView.View>
            </ListView>
        </StackPanel>
    </Grid>
</Window>




using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;

namespace TaskbarAppsListing
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            RefreshAppsList();
        }

        // Button click to refresh the list
        private void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            RefreshAppsList();
        }

        private void RefreshAppsList()
        {
            var apps = GetTaskbarApps();
            AppsListView.ItemsSource = apps;
        }

        #region P/Invoke Declarations

        // Delegate for window enumeration
        private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

        [DllImport("user32.dll")]
        private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

        [DllImport("user32.dll")]
        private static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetWindowTextLength(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

        // Retrieves the process ID for a window
        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

        // Retrieve extended window styles
        [DllImport("user32.dll", SetLastError = true)]
        private static extern int GetWindowLong(IntPtr hWnd, int nIndex);

        private const int GWL_EXSTYLE = -20;
        private const int WS_EX_TOOLWINDOW = 0x00000080;

        #endregion

        #region Helper Methods

        /// <summary>
        /// Enumerates all top‑level windows and returns a list of unique TaskbarAppInfo objects.
        /// </summary>
        /// <returns>A list of TaskbarAppInfo items for visible windows with non‑empty titles that are not tool windows.</returns>
        private List<TaskbarAppInfo> GetTaskbarApps()
        {
            var apps = new List<TaskbarAppInfo>();
            var seenProcessIds = new HashSet<int>();

            EnumWindows((hWnd, lParam) =>
            {
                // Skip if the window is not visible
                if (!IsWindowVisible(hWnd))
                    return true;

                // Skip if the window has the tool window extended style.
                int exStyle = GetWindowLong(hWnd, GWL_EXSTYLE);
                if ((exStyle & WS_EX_TOOLWINDOW) != 0)
                    return true;

                // Get the window title length
                int length = GetWindowTextLength(hWnd);
                if (length == 0)
                    return true; // Skip windows with no title

                // Get the window title
                StringBuilder sb = new StringBuilder(length + 1);
                GetWindowText(hWnd, sb, sb.Capacity);
                string windowTitle = sb.ToString();
                if (string.IsNullOrWhiteSpace(windowTitle))
                    return true;

                // Get process ID
                GetWindowThreadProcessId(hWnd, out uint pid);
                int processId = (int)pid;

                // Add only one entry per process.
                if (!seenProcessIds.Contains(processId))
                {
                    string processName = "";
                    try
                    {
                        Process proc = Process.GetProcessById(processId);
                        processName = proc.ProcessName;
                    }
                    catch { }

                    apps.Add(new TaskbarAppInfo
                    {
                        ProcessId = processId,
                        ProcessName = processName,
                        WindowTitle = windowTitle
                    });
                    seenProcessIds.Add(processId);
                }

                return true; // Continue enumerating
            }, IntPtr.Zero);

            return apps;
        }

        #endregion
    }

    // A simple class to hold taskbar app information.
    public class TaskbarAppInfo
    {
        public int ProcessId { get; set; }
        public string ProcessName { get; set; }
        public string WindowTitle { get; set; }
    }
}
